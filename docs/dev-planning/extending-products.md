# Arquitetura de Adicionais de Produtos (Product Addons)## Visão GeralSistema para suportar **adicionais/complementos** em produtos (similar ao iFood), permitindo que clientes personalizem pedidos com opções extras como tamanhos, bordas, sabores, etc.## Estrutura de Tabelas### 1. `product_addon_groups` - Grupos de AdicionaisRepresenta categorias de adicionais (ex: "Tamanhos", "Bordas", "Molhos").export const productAddonGroups = newTable(    "product_addon_groups",    {        id: varchar("id", { length: 255 })            .primaryKey()            .$defaultFn(() => crypto.randomUUID()),        organizacaoId: varchar("organizacao_id", { length: 255 })            .references(() => organizations.id)            .notNull(),                // Informações básicas        titulo: text("titulo").notNull(), // Ex: "Tamanhos", "Adicionais de Carne"        descricao: text("descricao"), // Descrição opcional                // Configurações de seleção        obrigatorio: boolean("obrigatorio").notNull().default(false), // Cliente precisa escolher?        selecaoMinima: integer("selecao_minima").notNull().default(0), // Min. de itens a selecionar        selecaoMaxima: integer("selecao_maxima"), // Max. de itens (null = ilimitado)                // Comportamento        tipo: text("tipo").notNull().default("ADICIONAL"), // ADICIONAL | TAMANHO | VARIACAO        ordem: integer("ordem").notNull().default(0), // Ordem de exibição                // Status        ativo: boolean("ativo").notNull().default(true),        dataCriacao: timestamp("data_criacao").notNull().defaultNow(),        dataAtualizacao: timestamp("data_atualizacao").notNull().defaultNow(),    },    (table) => ({        organizacaoIdIdx: index("idx_addon_groups_organizacao").on(table.organizacaoId),        ativoIdx: index("idx_addon_groups_ativo").on(table.ativo),    }),);
Campos importantes:
obrigatorio: Define se o cliente deve escolher pelo menos uma opção
selecaoMinima/Maxima: Controla quantos itens podem ser selecionados
tipo: Diferencia comportamentos (tamanho muda preço base vs adicional soma ao preço)
2. product_addons - Adicionais Individuais
Opções específicas dentro de cada grupo (ex: "Bacon +R$5", "Borda Catupiry +R$8").
export const productAddons = newTable(    "product_addons",    {        id: varchar("id", { length: 255 })            .primaryKey()            .$defaultFn(() => crypto.randomUUID()),        organizacaoId: varchar("organizacao_id", { length: 255 })            .references(() => organizations.id)            .notNull(),        grupoId: varchar("grupo_id", { length: 255 })            .references(() => productAddonGroups.id, { onDelete: "cascade" })            .notNull(),                // Informações básicas        nome: text("nome").notNull(), // Ex: "Bacon", "Borda Catupiry"        descricao: text("descricao"), // Descrição detalhada                // Preços        precoAdicional: doublePrecision("preco_adicional").notNull().default(0), // Valor adicional        precoCusto: doublePrecision("preco_custo"), // Custo do adicional                // Estoque (opcional)        controlaEstoque: boolean("controla_estoque").notNull().default(false),        quantidadeEstoque: doublePrecision("quantidade_estoque"),                // Visual        imagemUrl: text("imagem_url"), // Imagem do adicional        ordem: integer("ordem").notNull().default(0), // Ordem de exibição                // Status        ativo: boolean("ativo").notNull().default(true),        selecionadoPorPadrao: boolean("selecionado_por_padrao").notNull().default(false),        dataCriacao: timestamp("data_criacao").notNull().defaultNow(),        dataAtualizacao: timestamp("data_atualizacao").notNull().defaultNow(),    },    (table) => ({        grupoIdIdx: index("idx_addons_grupo").on(table.grupoId),        organizacaoIdIdx: index("idx_addons_organizacao").on(table.organizacaoId),        ativoIdx: index("idx_addons_ativo").on(table.ativo),    }),);
Campos importantes:
precoAdicional: Valor que será somado ao preço base
controlaEstoque: Permite controlar disponibilidade de adicionais específicos
selecionadoPorPadrao: Útil para opções comuns (ex: "Sem cebola" em hambúrgueres)
3. product_addon_group_links - Vínculo Produto ↔ Grupos
Define quais grupos de adicionais estão disponíveis para cada produto.
export const productAddonGroupLinks = newTable(    "product_addon_group_links",    {        id: varchar("id", { length: 255 })            .primaryKey()            .$defaultFn(() => crypto.randomUUID()),        organizacaoId: varchar("organizacao_id", { length: 255 })            .references(() => organizations.id)            .notNull(),        produtoId: varchar("produto_id", { length: 255 })            .references(() => products.id, { onDelete: "cascade" })            .notNull(),        grupoAdicionaisId: varchar("grupo_adicionais_id", { length: 255 })            .references(() => productAddonGroups.id, { onDelete: "cascade" })            .notNull(),                // Configurações específicas (override do grupo)        obrigatorio: boolean("obrigatorio"), // null = usa config do grupo        selecaoMinima: integer("selecao_minima"), // null = usa config do grupo        selecaoMaxima: integer("selecao_maxima"), // null = usa config do grupo                ordem: integer("ordem").notNull().default(0),        ativo: boolean("ativo").notNull().default(true),        dataCriacao: timestamp("data_criacao").notNull().defaultNow(),    },    (table) => ({        produtoIdIdx: index("idx_addon_links_produto").on(table.produtoId),        grupoIdIdx: index("idx_addon_links_grupo").on(table.grupoAdicionaisId),        produtoGrupoIdx: index("idx_addon_links_produto_grupo").on(            table.produtoId,            table.grupoAdicionaisId,        ),    }),);
Funcionalidade de Override:
Permite customizar regras por produto
Ex: Grupo "Molhos" permite até 3 seleções, mas na "Pizza Especial" permite apenas 1
4. sale_item_addons - Adicionais em Vendas
Registra quais adicionais foram escolhidos em cada item vendido (histórico).
export const saleItemAddons = newTable(    "sale_item_addons",    {        id: varchar("id", { length: 255 })            .primaryKey()            .$defaultFn(() => crypto.randomUUID()),        organizacaoId: varchar("organizacao_id", { length: 255 })            .references(() => organizations.id)            .notNull(),                // Relacionamentos        itemVendaId: varchar("item_venda_id", { length: 255 })            .references(() => saleItems.id, { onDelete: "cascade" })            .notNull(),        adicionalId: varchar("adicional_id", { length: 255 })            .references(() => productAddons.id)            .notNull(),                // Dados do adicional no momento da venda (snapshot)        adicionalNome: text("adicional_nome").notNull(),        adicionalGrupoNome: text("adicional_grupo_nome").notNull(),                // Valores        quantidade: doublePrecision("quantidade").notNull().default(1), // Quantas porções        precoUnitario: doublePrecision("preco_unitario").notNull(), // Preço no momento da venda        custoUnitario: doublePrecision("custo_unitario"), // Custo no momento da venda        valorTotal: doublePrecision("valor_total").notNull(), // quantidade * precoUnitario                dataCriacao: timestamp("data_criacao").notNull().defaultNow(),    },    (table) => ({        itemVendaIdIdx: index("idx_sale_item_addons_item").on(table.itemVendaId),        adicionalIdIdx: index("idx_sale_item_addons_adicional").on(table.adicionalId),    }),);
Por que snapshot?
Mantém histórico mesmo se preços/nomes mudarem depois
Permite análises precisas de vendas passadas
Relations (Drizzle ORM)
// Relationsexport const productAddonGroupsRelations = relations(productAddonGroups, ({ many }) => ({    adicionais: many(productAddons),    vinculos: many(productAddonGroupLinks),}));export const productAddonsRelations = relations(productAddons, ({ one, many }) => ({    grupo: one(productAddonGroups, {        fields: [productAddons.grupoId],        references: [productAddonGroups.id],    }),    vendasItens: many(saleItemAddons),}));export const productAddonGroupLinksRelations = relations(productAddonGroupLinks, ({ one }) => ({    produto: one(products, {        fields: [productAddonGroupLinks.produtoId],        references: [products.id],    }),    grupo: one(productAddonGroups, {        fields: [productAddonGroupLinks.grupoAdicionaisId],        references: [productAddonGroups.id],    }),}));export const saleItemAddonsRelations = relations(saleItemAddons, ({ one }) => ({    itemVenda: one(saleItems, {        fields: [saleItemAddons.itemVendaId],        references: [saleItems.id],    }),    adicional: one(productAddons, {        fields: [saleItemAddons.adicionalId],        references: [productAddons.id],    }),}));// Atualizar products relationsexport const productsRelations = relations(products, ({ one, many }) => ({    organizacao: one(organizations, {        fields: [products.organizacaoId],        references: [organizations.id],    }),    pedidos: many(saleItems),    gruposAdicionais: many(productAddonGroupLinks), // NOVO}));// Atualizar saleItems relationsexport const saleItemsRelations = relations(saleItems, ({ one, many }) => ({    produto: one(products, {        fields: [saleItems.produtoId],        references: [products.id],    }),    venda: one(sales, {        fields: [saleItems.vendaId],        references: [sales.id],    }),    adicionais: many(saleItemAddons), // NOVO}));
Exemplo de Uso Completo
Setup: Criar Pizza com Adicionais
// 1. Criar grupos de adicionaisconst grupoTamanhos = await db.insert(productAddonGroups).values({    organizacaoId: "org-123",    titulo: "Tamanho",    descricao: "Escolha o tamanho da pizza",    obrigatorio: true,    selecaoMinima: 1,    selecaoMaxima: 1,    tipo: "TAMANHO",}).returning();const grupoBordas = await db.insert(productAddonGroups).values({    organizacaoId: "org-123",    titulo: "Bordas",    descricao: "Adicione uma borda especial",    obrigatorio: false,    selecaoMinima: 0,    selecaoMaxima: 1,    tipo: "ADICIONAL",}).returning();const grupoIngredientes = await db.insert(productAddonGroups).values({    organizacaoId: "org-123",    titulo: "Ingredientes Extras",    descricao: "Adicione até 3 ingredientes extras",    obrigatorio: false,    selecaoMinima: 0,    selecaoMaxima: 3,    tipo: "ADICIONAL",}).returning();// 2. Criar adicionaisawait db.insert(productAddons).values([    // Tamanhos    {         grupoId: grupoTamanhos[0].id,         organizacaoId: "org-123",        nome: "Pequena (4 fatias)",         precoAdicional: 0,        precoCusto: 0,        ordem: 1,    },    {         grupoId: grupoTamanhos[0].id,         organizacaoId: "org-123",        nome: "Média (6 fatias)",         precoAdicional: 10,        precoCusto: 4,        ordem: 2,    },    {         grupoId: grupoTamanhos[0].id,         organizacaoId: "org-123",        nome: "Grande (8 fatias)",         precoAdicional: 20,        precoCusto: 8,        ordem: 3,    },        // Bordas    {         grupoId: grupoBordas[0].id,         organizacaoId: "org-123",        nome: "Borda Catupiry",         precoAdicional: 8,        precoCusto: 3,    },    {         grupoId: grupoBordas[0].id,         organizacaoId: "org-123",        nome: "Borda Cheddar",         precoAdicional: 10,        precoCusto: 4,    },        // Ingredientes extras    {         grupoId: grupoIngredientes[0].id,         organizacaoId: "org-123",        nome: "Bacon",         precoAdicional: 5,        precoCusto: 2,    },    {         grupoId: grupoIngredientes[0].id,         organizacaoId: "org-123",        nome: "Mussarela Extra",         precoAdicional: 4,        precoCusto: 2,    },]);// 3. Vincular grupos ao produto (Pizza Margherita)await db.insert(productAddonGroupLinks).values([    {         produtoId: "pizza-margherita-id",         organizacaoId: "org-123",        grupoAdicionaisId: grupoTamanhos[0].id,         ordem: 1,        ativo: true,    },    {         produtoId: "pizza-margherita-id",         organizacaoId: "org-123",        grupoAdicionaisId: grupoBordas[0].id,         ordem: 2,        ativo: true,    },    {         produtoId: "pizza-margherita-id",         organizacaoId: "org-123",        grupoAdicionaisId: grupoIngredientes[0].id,         ordem: 3,        ativo: true,    },]);
Vendendo um Item com Adicionais
// 4. Na venda, registrar o item baseconst saleItem = await db.insert(saleItems).values({    vendaId: "venda-123",    organizacaoId: "org-123",    clienteId: "cliente-456",    produtoId: "pizza-margherita-id",    quantidade: 1,    valorVendaUnitario: 30, // Preço base da pizza    valorCustoUnitario: 12,    valorVendaTotalBruto: 30,    valorTotalDesconto: 0,    valorVendaTotalLiquido: 30, // Será atualizado depois    valorCustoTotal: 12,}).returning();// 5. Cliente escolheu: // - Tamanho Grande (+R$20)// - Borda Catupiry (+R$8)// - Bacon (+R$5)const adicionaisEscolhidos = [    {        adicionalId: "tamanho-grande-id",        adicionalNome: "Grande (8 fatias)",        adicionalGrupoNome: "Tamanho",        quantidade: 1,        precoUnitario: 20,        custoUnitario: 8,        valorTotal: 20,    },    {        adicionalId: "borda-catupiry-id",        adicionalNome: "Borda Catupiry",        adicionalGrupoNome: "Bordas",        quantidade: 1,        precoUnitario: 8,        custoUnitario: 3,        valorTotal: 8,    },    {        adicionalId: "bacon-id",        adicionalNome: "Bacon",        adicionalGrupoNome: "Ingredientes Extras",        quantidade: 1,        precoUnitario: 5,        custoUnitario: 2,        valorTotal: 5,    },];// Inserir adicionaisawait db.insert(saleItemAddons).values(    adicionaisEscolhidos.map(addon => ({        ...addon,        organizacaoId: "org-123",        itemVendaId: saleItem[0].id,    })));// 6. Atualizar valores totais do itemconst valorAdicionais = adicionaisEscolhidos.reduce(    (sum, addon) => sum + addon.valorTotal,     0); // 20 + 8 + 5 = 33const custoAdicionais = adicionaisEscolhidos.reduce(    (sum, addon) => sum + (addon.custoUnitario || 0),     0); // 8 + 3 + 2 = 13await db.update(saleItems)    .set({        valorVendaTotalLiquido: 30 + valorAdicionais, // R$ 63        valorCustoTotal: 12 + custoAdicionais, // R$ 25    })    .where(eq(saleItems.id, saleItem[0].id));// Total final: R$30 (base) + R$33 (adicionais) = R$63// Custo total: R$12 (base) + R$13 (adicionais) = R$25// Margem: R$38 (60%)
Queries Úteis
Buscar Produto com Todos os Adicionais Disponíveis
async function getProductWithAddons(productId: string, organizacaoId: string) {    const product = await db.query.products.findFirst({        where: and(            eq(products.id, productId),            eq(products.organizacaoId, organizacaoId),        ),        with: {            gruposAdicionais: {                where: eq(productAddonGroupLinks.ativo, true),                orderBy: asc(productAddonGroupLinks.ordem),                with: {                    grupo: {                        with: {                            adicionais: {                                where: eq(productAddons.ativo, true),                                orderBy: asc(productAddons.ordem),                            },                        },                    },                },            },        },    });    return product;}
Buscar Item de Venda com Adicionais
async function getSaleItemWithAddons(saleItemId: string) {    const saleItem = await db.query.saleItems.findFirst({        where: eq(saleItems.id, saleItemId),        with: {            produto: true,            adicionais: {                orderBy: asc(saleItemAddons.adicionalGrupoNome),            },        },    });    return saleItem;}
Relatório: Adicionais Mais Vendidos
async function getMostSoldAddons(    organizacaoId: string,     startDate: Date,     endDate: Date) {    const result = await db        .select({            adicionalId: saleItemAddons.adicionalId,            adicionalNome: saleItemAddons.adicionalNome,            adicionalGrupo: saleItemAddons.adicionalGrupoNome,            quantidadeVendida: sum(saleItemAddons.quantidade),            receitaTotal: sum(saleItemAddons.valorTotal),        })        .from(saleItemAddons)        .innerJoin(saleItems, eq(saleItemAddons.itemVendaId, saleItems.id))        .innerJoin(sales, eq(saleItems.vendaId, sales.id))        .where(            and(                eq(saleItemAddons.organizacaoId, organizacaoId),                gte(sales.dataVenda, startDate),                lte(sales.dataVenda, endDate),            )        )        .groupBy(            saleItemAddons.adicionalId,             saleItemAddons.adicionalNome,            saleItemAddons.adicionalGrupoNome,        )        .orderBy(desc(sum(saleItemAddons.valorTotal)));    return result;}
Fluxo de Validação no Frontend/Backend
Frontend - Validação de Seleção
function validateAddonSelection(    grupo: TProductAddonGroupEntity,    adicionaisSelecionados: string[],    override?: { obrigatorio?: boolean; selecaoMinima?: number; selecaoMaxima?: number }) {    const obrigatorio = override?.obrigatorio ?? grupo.obrigatorio;    const selecaoMinima = override?.selecaoMinima ?? grupo.selecaoMinima;    const selecaoMaxima = override?.selecaoMaxima ?? grupo.selecaoMaxima;        const quantidadeSelecionada = adicionaisSelecionados.length;        if (obrigatorio && quantidadeSelecionada === 0) {        return {            valid: false,            message: `Selecione pelo menos uma opção em "${grupo.titulo}"`,        };    }        if (quantidadeSelecionada < selecaoMinima) {        return {            valid: false,            message: `Selecione pelo menos ${selecaoMinima} opções em "${grupo.titulo}"`,        };    }        if (selecaoMaxima && quantidadeSelecionada > selecaoMaxima) {        return {            valid: false,            message: `Selecione no máximo ${selecaoMaxima} opções em "${grupo.titulo}"`,        };    }        return { valid: true };}
Backend - Cálculo de Preço com Adicionais
async function calculateItemPrice(    produtoId: string,    quantidade: number,    adicionaisIds: string[],    organizacaoId: string,) {    // Buscar produto    const produto = await db.query.products.findFirst({        where: and(            eq(products.id, produtoId),            eq(products.organizacaoId, organizacaoId),        ),    });        if (!produto) throw new Error("Produto não encontrado");        // Buscar adicionais    const adicionais = await db.query.productAddons.findMany({        where: and(            inArray(productAddons.id, adicionaisIds),            eq(productAddons.organizacaoId, organizacaoId),            eq(productAddons.ativo, true),        ),    });        // Calcular valores    const precoBaseProduto = produto.precoVenda || 0;    const custoBaseProduto = produto.precoCusto || 0;        const precoAdicionais = adicionais.reduce(        (sum, addon) => sum + addon.precoAdicional,         0    );        const custoAdicionais = adicionais.reduce(        (sum, addon) => sum + (addon.precoCusto || 0),         0    );        return {        precoUnitario: precoBaseProduto + precoAdicionais,        custoUnitario: custoBaseProduto + custoAdicionais,        precoTotal: (precoBaseProduto + precoAdicionais) * quantidade,        custoTotal: (custoBaseProduto + custoAdicionais) * quantidade,        adicionais: adicionais,    };}
Considerações de Performance
Índices Recomendados
Todos os índices já estão incluídos nos schemas acima:
product_addon_groups: organizacaoId, ativo
product_addons: grupoId, organizacaoId, ativo
product_addon_group_links: produtoId, grupoAdicionaisId, composto produtoId + grupoAdicionaisId
sale_item_addons: itemVendaId, adicionalId
Caching Sugerido
Para produtos com adicionais, considere:
Cache Redis dos grupos + adicionais por produto (TTL: 1h)
Invalidar cache ao atualizar adicionais
Queries read-heavy, writes menos frequentes
Migração Gradual
Fase 1: Setup Inicial
Criar tabelas no banco
Popular grupos básicos (Tamanhos, Bordas)
Testar com 1-2 produtos piloto
Fase 2: Integração
Atualizar API de produtos para incluir adicionais
Criar interface de administração
Atualizar fluxo de vendas
Fase 3: Rollout
Migrar produtos prioritários
Treinar equipe
Habilitar para todos os produtos
Benefícios da Arquitetura
✅ Flexível: Suporta múltiplos tipos (tamanhos, bordas, sabores, etc.)
✅ Reutilizável: Grupos podem ser compartilhados entre produtos
✅ Histórico: Registra snapshot dos adicionais na venda
✅ Performance: Índices otimizados para queries comuns
✅ Validação: Controla mínimo/máximo de seleções
✅ Escalável: Novos campos podem ser adicionados sem quebrar o sistema
✅ Análise: Permite relatórios detalhados sobre preferências dos clientes
Possíveis Extensões Futuras
1. Regras de Negócio Avançadas
Adicionais incompatíveis (ex: "Sem cebola" + "Cebola Extra")
Descontos em combos de adicionais
Limites por horário (promoções)
2. Sugestões Inteligentes
"Clientes que compraram isso também adicionaram..."
Adicionais mais populares por região/horário
3. Controle de Estoque Integrado
Alertas quando ingrediente acabar
Desabilitar adicionais automaticamente
4. Personalização por Canal
Preços diferentes para delivery vs presencial
Adicionais exclusivos por canal
Referências
Schema: services/drizzle/schema/product-addons.ts (a criar)
Migrations: drizzle/00XX_add_product_addons.sql (a criar)
API: pages/api/products/addons/* (a criar)
Components: components/Products/AddonsManager.tsx (a criar)